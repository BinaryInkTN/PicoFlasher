import os
import sys
import time
import shutil
import subprocess
import threading
from pathlib import Path
from typing import Optional, List, Dict, Any
import psutil
import requests
from tqdm import tqdm
import hashlib

from .exceptions import FlashError, ValidationError
from .utils import get_disk_info, format_drive, mount_drive, unmount_drive
from .validators import validate_iso, validate_usb_device, validate_checksum


class ISOFlasher:
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.current_operation = None
        self.progress_callback = None
        
    def list_usb_devices(self) -> List[Dict[str, Any]]:
        """List all available USB devices"""
        devices = []
        for partition in psutil.disk_partitions():
            try:
                if 'removable' in partition.opts or self._is_usb_device(partition.device):
                    usage = psutil.disk_usage(partition.mountpoint)
                    devices.append({
                        'device': partition.device,
                        'mountpoint': partition.mountpoint,
                        'total_size': usage.total,
                        'used': usage.used,
                        'free': usage.free,
                        'filesystem': partition.fstype
                    })
            except (PermissionError, OSError):
                continue
        return devices
    
    def _is_usb_device(self, device_path: str) -> bool:
        """Check if device is USB"""
        try:
            if sys.platform == 'linux':
                # Check via sysfs on Linux
                device_name = os.path.basename(device_path.rstrip('/'))
                sysfs_path = f"/sys/block/{device_name}/device"
                if os.path.exists(sysfs_path):
                    return True
            elif sys.platform == 'win32':
                # Windows implementation
                pass
            return False
        except:
            return False
    
    def flash_iso(
        self,
        iso_path: str,
        usb_device: str,
        block_size: int = 4096,
        verify: bool = True,
        format_first: bool = True
    ) -> None:
        """Flash ISO to USB device"""
        try:
            # Validate inputs
            validate_iso(iso_path)
            validate_usb_device(usb_device)
            
            # Unmount device
            self._log(f"Unmounting {usb_device}")
            unmount_drive(usb_device)
            
            # Format if requested
            if format_first:
                self._log(f"Formatting {usb_device}")
                format_drive(usb_device, 'fat32')
            
            # Flash ISO
            self._log(f"Flashing {iso_path} to {usb_device}")
            self._dd_iso_to_device(iso_path, usb_device, block_size)
            
            # Verify if requested
            if verify:
                self._log("Verifying flash")
                self._verify_flash(iso_path, usb_device)
            
            self._log("Flash completed successfully!")
            
        except Exception as e:
            raise FlashError(f"Failed to flash ISO: {str(e)}")
    
    def _dd_iso_to_device(self, iso_path: str, usb_device: str, block_size: int) -> None:
        """Use dd-like operation to write ISO to device"""
        iso_size = os.path.getsize(iso_path)
        
        if sys.platform == 'linux':
            cmd = [
                'dd', f'if={iso_path}', f'of={usb_device}',
                f'bs={block_size}', 'status=progress'
            ]
        elif sys.platform == 'win32':
            # Use Windows equivalent
            cmd = [
                'powershell', '-Command',
                f'$iso = Get-Item "{iso_path}"; '
                f'$usb = Get-WmiObject -Class Win32_DiskDrive | '
                f'Where-Object {{$_.DeviceID -eq "\\\\.\\{usb_device}"}}; '
                f'Write-Host "Flashing..."'
            ]
        else:
            raise FlashError("Unsupported platform")
        
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            # Monitor progress
            self._monitor_dd_progress(process, iso_size)
            
        except subprocess.CalledProcessError as e:
            raise FlashError(f"dd command failed: {e.stderr}")
    
    def _monitor_dd_progress(self, process: subprocess.Popen, total_size: int) -> None:
        """Monitor dd progress and update callback"""
        with tqdm(total=total_size, unit='B', unit_scale=True, desc="Flashing") as pbar:
            while process.poll() is None:
                try:
                    # Parse dd output for progress (Linux specific)
                    line = process.stderr.readline()
                    if 'bytes' in line:
                        # Extract transferred bytes
                        parts = line.split()
                        if len(parts) >= 1:
                            try:
                                transferred = int(parts[0])
                                pbar.update(transferred - pbar.n)
                            except ValueError:
                                pass
                    time.sleep(0.1)
                except:
                    break
            
            # Wait for process to complete
            process.wait()
            
            if process.returncode != 0:
                raise FlashError(f"Flash process failed with return code {process.returncode}")
    
    def _verify_flash(self, iso_path: str, usb_device: str) -> None:
        """Verify the flashed content matches the ISO"""
        iso_hash = self._calculate_file_hash(iso_path)
        
        # Read first few MB from USB to verify
        try:
            if sys.platform == 'linux':
                verify_cmd = [
                    'dd', f'if={usb_device}', 'bs=1M', 'count=100', 'status=none'
                ]
                result = subprocess.run(verify_cmd, capture_output=True, check=True)
                usb_hash = hashlib.sha256(result.stdout).hexdigest()
                
                # Compare with beginning of ISO
                with open(iso_path, 'rb') as f:
                    iso_start = f.read(100 * 1024 * 1024)
                iso_partial_hash = hashlib.sha256(iso_start).hexdigest()
                
                if usb_hash != iso_partial_hash:
                    raise FlashError("Verification failed: USB content doesn't match ISO")
                    
        except subprocess.CalledProcessError as e:
            raise FlashError(f"Verification failed: {e.stderr}")
    
    def _calculate_file_hash(self, file_path: str, algorithm: str = 'sha256') -> str:
        """Calculate file hash"""
        hash_func = hashlib.new(algorithm)
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                hash_func.update(chunk)
        return hash_func.hexdigest()
    
    def _log(self, message: str) -> None:
        """Log message if verbose mode is enabled"""
        if self.verbose:
            print(f"[INFO] {message}")
    
    def download_iso(self, url: str, destination: str) -> None:
        """Download ISO from URL with progress bar"""
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            total_size = int(response.headers.get('content-length', 0))
            
            with open(destination, 'wb') as file, tqdm(
                desc="Downloading",
                total=total_size,
                unit='B',
                unit_scale=True,
                unit_divisor=1024,
            ) as bar:
                for data in response.iter_content(chunk_size=4096):
                    size = file.write(data)
                    bar.update(size)
                    
        except requests.RequestException as e:
            raise FlashError(f"Download failed: {str(e)}")